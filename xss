ReactiveException: java.util.concurrent.TimeoutException: Did not observe any item or terminal signal within 240000ms in 'flatMap' (and no fallback has been configured)

package net.jpmchase.ccb.esignd.httphelper;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;

import java.net.URI;
import java.time.Duration;

@Service
@Slf4j
public class WebClientHelper {

    @Autowired
    @Qualifier("webclient")
    private WebClient webClient;

    public <T> T fetchResource(URI uri, String token, Class<T> responseType) {
        return webClient.get()
                .uri(uri)
                .header("Authorization", "Bearer " + token)
                .accept(MediaType.APPLICATION_JSON, MediaType.APPLICATION_PDF)
                .retrieve()
                .bodyToMono(responseType)
                .timeout(Duration.ofSeconds(240))
                .block();
    }

    public <T, R> R postResource(URI uri, String token, T requestBody, Class<R> responseType, MediaType contentType) {
        return webClient.post()
                .uri(uri)
                .header("Authorization", "Bearer " + token)
                .contentType(contentType)
                .accept(MediaType.APPLICATION_JSON)
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(responseType)
                .timeout(Duration.ofSeconds(240))
                .block();
    }

    public <T, R> R putResource(URI uri, String token, T requestBody, Class<R> responseType, MediaType contentType) {
        return webClient.put()
                .uri(uri)
                .header("Authorization", "Bearer " + token)
                .contentType(contentType)
                .accept(MediaType.APPLICATION_JSON)
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(responseType)
                .timeout(Duration.ofSeconds(240))
                .block();
    }

    public <T, R> R postFormResource(String uri, String token, MultiValueMap<String, String> formData, Class<R> responseType, MediaType contentType) {
        return webClient.post()
                .uri(uri)
                .header("Authorization", "Bearer " + token)
                .contentType(contentType)
                .accept(MediaType.APPLICATION_JSON)
                .body(BodyInserters.fromFormData(formData))
                .retrieve()
                .bodyToMono(responseType)
                .timeout(Duration.ofSeconds(240))
                .block();
    }
}


package net.jpmchase.ccb.esignd.config;

import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import lombok.extern.slf4j.Slf4j;
import net.jpmchase.ccb.esignd.utilities.Constants;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;
import reactor.netty.transport.ProxyProvider;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.TrustManagerFactory;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.security.KeyStore;

@Configuration
@Slf4j
public class WebConfig {

    @Value("${weblclient.memory}")
    private int dataMemory;
    private final DocuSignWebClientProperties docuSignWebClientProperties;

    public WebConfig(DocuSignWebClientProperties docuSignWebClientProperties) {
        this.docuSignWebClientProperties = docuSignWebClientProperties;
    }

    @Bean(name = "webclient")
    @Profile("local")
    public WebClient getWebClientAppProxy() {
        return WebClient.builder().exchangeStrategies(ExchangeStrategies.builder()
                .codecs(configurer -> configurer
                        .defaultCodecs()
                        .maxInMemorySize(dataMemory * Constants.BYTES * Constants.BYTES))
                .build()).clientConnector(new ReactorClientHttpConnector(HttpClient.create().proxy(proxy -> proxy.type(ProxyProvider.Proxy.HTTP)
                .host(this.docuSignWebClientProperties.getProxyHostValue()).port(this.docuSignWebClientProperties.getProxyPortValue())))).build();
    }

    @Bean(name = "webclient")
    @Profile("!local")
    public WebClient getWebClientCloudProxy() throws Exception {
        String clientKeystore = this.docuSignWebClientProperties.getKeyStore();
        String password = this.docuSignWebClientProperties.getKeystorePassword();

        log.debug("inside initializing webClientCloudProxy  clientKeystore {} ", clientKeystore);

        File keyStoreFile = new File(clientKeystore);
        log.debug("keyStore absolute path {}  ", keyStoreFile.getAbsolutePath());

        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        log.debug("keystore loaded : {} ", keyStore.getType());
        try (InputStream keyStoreStream = new FileInputStream(keyStoreFile)) {
            keyStore.load(keyStoreStream, password.toCharArray());
        }

        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        keyManagerFactory.init(keyStore, password.toCharArray());
        log.debug("keyManagerFactory loaded : {} ", keyManagerFactory.getAlgorithm());

        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(keyStore);
        log.debug("trustManagerFactory loaded : {} ", trustManagerFactory.getAlgorithm());

        SslContext sslContext = SslContextBuilder.forClient()
                .keyManager(keyManagerFactory)
                .trustManager(trustManagerFactory)
                .build();

        log.debug("sslContext initialized  {} ", sslContext);

        HttpClient httpClient = HttpClient.create()
                .secure(sslContextSpec -> sslContextSpec.sslContext(sslContext))
                .proxy(proxySpec -> proxySpec.type(ProxyProvider.Proxy.HTTP)
                        .host(this.docuSignWebClientProperties.getProxyHostValue())
                        .port(this.docuSignWebClientProperties.getProxyPortValue()));

        log.debug("httpClient initialized  {} ", httpClient);

        return WebClient.builder()
                .exchangeStrategies(ExchangeStrategies.builder()
                        .codecs(configurer -> configurer
                                .defaultCodecs()
                                .maxInMemorySize(dataMemory * Constants.BYTES * Constants.BYTES))
                        .build())
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .build();
    }

}



import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

public class InputSanitizationFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        // Sanitize input parameters
        String sanitizedInput = sanitize(httpRequest.getParameter("input"));
        httpRequest.setAttribute("input", sanitizedInput);
        
        // Proceed with the filter chain
        chain.doFilter(request, response);
    }

    private String sanitize(String input) {
        if (input != null) {
            // Remove harmful characters (e.g., <, >, and script tags for XSS)
            input = input.replaceAll("<", "&lt;")
                         .replaceAll(">", "&gt;")
                         .replaceAll("script", "");  // Block potential XSS
        }
        return input;
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Initialization code, if necessary
    }

    @Override
    public void destroy() {
        // Cleanup code, if necessary
    }
}
